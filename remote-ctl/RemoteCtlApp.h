#ifndef REMOTECTLAPP_H
#define REMOTECTLAPP_H

#include <SDL2/SDL.h>
#include <cstdio>
#include <cstdlib>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <unistd.h>
#include <vector>
#include <utility>

#define DEFAULT_MESG_SIZE 512 ///< 512 bytes default packet size for transmitting gamepad state

/**
 * This struct is used for storing the state of the Xbox controller in a code
 * friendly manner and for transmitting its state over TCP. Note that this struct
 * created on and transmitted from an Intel machine meaning multibyte values,
 * namely the first 6 fields which are doubles, will be in little-endian byte
 * order. The button array, being a boolean array, is unaffected.
 */
struct GamepadState
{
    double axis_x; ///< Horizontal axis of left stick. Range [-1, 1]. -1 is full left.
    double axis_y; ///< Vertical axis of left stick. Range [-1, 1]. -1 is full up.
    double axis_z;

    double axis_yaw;
    double axis_pitch;
    double axis_roll;

    char button[32]; ///< button's number is its index into the array. Boolean: 0 or 1. 1 is pressed.
};

/**
 * This is a server for remote control of the Jetson car. It accepts connections
 * from the Jetson car over a TCP socket on port 5309 and sends a copy of the
 * current gamepad state at 20 Hz. It expects the Xbox controller to be the first
 * device available i.e. /dev/js0. If no joystick is detected, the program will
 * still run, though manual controll will not be possible. If there is a server
 * already running, this server will explicitly fail to start.
 */
class RemoteCtlApp
{
private:
    bool running;                 ///< keep the server loop running and controls application exit
    unsigned long last_refresh;   ///< millisecond Unix time when the console was last updated with debug info
    unsigned long last_broadcast; ///< millisecond Unix time when the gamepad's state was last transmitted to robot

    int gamepad;                       ///< index number of the gamepad we are using (0)
    struct GamepadState gamepad_state; ///< current gamepad state for transmission
    SDL_Joystick* sdl_gamepad;         ///< SDL library handle for the gamepad

    int robot_socket; ///< Unix file handle for the TCP server socket
    std::vector<std::pair<int, struct sockaddr_in>> connections; ///< Holds all active connection sockets and the IP information of the client

    /**
     * Initializes the TCP server socket for listening for connections from the
     * Jetson car. Uses port 5309. The socket created will be non-blocking to
     * avoid blocking the application when checking for connections.
     *
     * @return Returns 0 on successful establishment of the socket. On failure,
     * returns the POSIX error code that occured during socket creation.
     */
    int _init_tcp();         ///< Initializes the server socket

    /**
     * Checks for any pending connections on the server socket and accepts them.
     * Accepted connections are placed into the 'connections' vector along with
     * the IP information of the client. Failed connections will simply be dropped.
     */
    void _connect_handler(); ///< Handles incoming connections from Jetson car

    /**
     * Transmits the current gamepad state to all connected clients. If errors
     * arise during transmission to a client, the connection will be closed and
     * that client will need to reconnect.
     */
    void _tx_handler(); ///< Transmits gamepad state to all clients.

    /**
     * Initializes the SDL I/O library for reading from the Xbox controller. Upon
     * success, SDL will be active and generate I/O events that report the
     * gamepad state and GUI / program actions such as a SIGINT from Control + C.
     *
     * @return Returns 0 or positive on success. Returns less than 0 on failure.
     */
    int _init_sdl(); ///< Initializes the SDL I/O library for reading the gamepad

    /**
     * Handles the events generated by the SDL I/O library, namely the gamepad
     * motions and any interrupt or exit signals, such as those generated by a
     * Control + C key.
     *
     * @param pointer to an SDL event retrieved from a call to SDL_PollEvent()
     */
    void _event(SDL_Event* Event); ///< SDL event handler
    void _loop();                  ///< Main server loop. Runs the connection and transmission handlers and provides debug info.
    void _cleanup();               ///< Cleanup function to ensure SDL is shut down correctly

public:
    RemoteCtlApp(); ///< Creates the server object. Note that a call to execute will still need to be made.

    /**
     * This is the server's main thread of execution. This function must be called.
     *
     * @return Returns 0 on normal server closure. Returns nonzero SDL error on
     * failure to initialize the SDL I/O library.
     */
    int execute(); ///< Runs the server. Must be called.
};

#endif
