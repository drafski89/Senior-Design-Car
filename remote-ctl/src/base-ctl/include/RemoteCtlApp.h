#ifndef REMOTECTLAPP_H
#define REMOTECTLAPP_H

#include <SDL2/SDL.h>
#include <cstdio>
#include <cstdlib>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <unistd.h>
#include <vector>
#include <utility>
#include <pthread.h>
#include <exception>
#include <stdexcept>

#define DEFAULT_MESG_SIZE 512 ///< 512 bytes default packet size for transmitting gamepad state

/**
 * This struct is used for storing the state of the Xbox controller in a code
 * friendly manner and for transmitting its state over TCP. Note that this struct
 * created on and transmitted from an Intel machine meaning multibyte values,
 * namely the first 6 fields which are doubles, will be in little-endian byte
 * order. The button array, being a boolean array, is unaffected.
 */
struct GamepadState
{
    double axis_lx; ///< Horizontal axis of left stick. Range [-1, 1]. -1 is full left.
    double axis_ly; ///< Vertical axis of left stick. Range [-1, 1]. -1 is full up.
    double axis_lt; ///< Left trigger axis. Range [-1, 1]. -1 is trigger fully released.

    double axis_rx; ///< Horizontal axis of right stick. Range [-1, 1]. -1 is full left.
    double axis_ry; ///< Vertical axis of right stick. Range [1-, 1]. -1 is full up.
    double axis_rt; ///< Right trigger axis. Range [-1, 1]. -1 is trigger fully released.

    /**
     * Button map:
     *
     * Button -> Index
     * A     - 0
     * B     - 1
     * X     - 2
     * Y     - 3
     * LB    - 4
     * RB    - 5
     * Back  - 6
     * Start - 7
     * Xbox  - 8
     * LS    - 9
     * RS    - 10
     */
    char button[32]; ///< button's number is its index into the array. Boolean: 0 or 1. 1 is pressed.
};

enum ButtonMap_t
{
    A_BTN = 0,
    B_BTN,
    X_BTN,
    Y_BTN,
    LB_BTN,
    RB_BTN,
    BACK_BTN,
    START_BTN,
    XBOX_BTN,
    LS_BTN,
    RS_BTN,
};

/**
 * This is a server for remote control of the Jetson car. It accepts connections
 * from the Jetson car over a TCP socket on port 5309 and sends a copy of the
 * current gamepad state at 20 Hz. It expects the Xbox controller to be the first
 * device available i.e. /dev/js0. If no joystick is detected, the program will
 * still run, though manual controll will not be possible. If there is a server
 * already running, this server will explicitly fail to start.
 */
class RemoteCtlApp
{
    friend void* connect_handler(void* app_ptr);
    friend void* tx_handler(void* app_ptr);

private:
    bool running;                 ///< keep the server loop running and controls application exit

    int gamepad;                       ///< index number of the gamepad we are using (0)
    struct GamepadState gamepad_state; ///< current gamepad state for transmission
    SDL_Joystick* sdl_gamepad;         ///< SDL library handle for the gamepad

    int robot_socket; ///< Unix file handle for the TCP server socket
    std::pair<int, struct sockaddr_in>* connection;

    pthread_t connect_thread;
    pthread_t tx_thread;
    pthread_mutex_t write_lock;

    /**
     * Handles the events generated by the SDL I/O library, namely the gamepad
     * motions and any interrupt or exit signals, such as those generated by a
     * Control + C key.
     *
     * @param pointer to an SDL event retrieved from a call to SDL_PollEvent()
     */
    void _event(SDL_Event* Event); ///< SDL event handler
    void _loop();                  ///< Main server loop. Runs the connection and transmission handlers and provides debug info.

public:
    RemoteCtlApp(); ///< Creates the server object. Note that a call to execute will still need to be made.
    ~RemoteCtlApp();

    /**
     * This is the server's main thread of execution. This function must be called.
     *
     * @return Returns 0 on normal server closure. Returns nonzero SDL error on
     * failure to initialize the SDL I/O library.
     */
    int execute(); ///< Runs the server. Must be called.
};

#endif
